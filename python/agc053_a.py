# AtCoder Grand Contest 053 A - >< again
# https://atcoder.jp/contests/agc053/tasks/agc053_a
# tag: 考察 数列

# 波を形を保ったまま振幅の小さなものに分割するイメージ……？

# 整数でなくていい場合を考えると、単純に各要素を同じ数字で
# 割ってやればよく、無限に分割可能。
# 整数を保ったままにしたいならどうするのか。

# 仮に N 分割すると仮定した場合、隣り合う要素同士の差分も
# また、N で割ったものになる。
# つまり、差が 1 より小さくなってしまうので、
# 隣り合う要素の差の最小値以上に分割することはできない。

# では、その最小値（d とする）なら全体で分割可能か？
# 仮に 5 と 2 が隣り合ってるとして、これを 3 つに分割してみる
# 5: 1 2 2
# 2: 0 1 1
# 上記のようにすれば分割できる。mod 3 が絡んでいそうなので、
# 元の数字を考えてみると
# 5: 5 6 7 (5 + i)
# 2: 2 3 4 (2 + i)
# ……みたいな感じ？

# もうひとつ例を考えてみると、
# 8: 8  9 10 11 12 
# 3: 3  4  5  6  7
# の mod 5 を取ると、
# 8: 1  1  2  2  2
# 3: 0  0  1  1  1
# というわけで、(元の数字 + 分割の i-1 番目) // 全体の分割数
# で分割可能っぽい。

# これは、上記の例でいうと 8 = 3 (mod 8-3) になるため。
# mod、つまり余りの数が上下で等しくなるので、数字が変化する
# 地点も同じになる。同じ 5 分割で差を広げてみると、

# 8: 1  1  2  2  2
# 2: 0  0  0  1  1

# という感じになり、問題ない。

def main():
    N = int(input())

    # 実は >< の情報は必要ない
    S = input()

    A = list(map(int, input().split()))

    # 隣り合う要素の差分の最小値＝分割数を求める
    max_div = min(abs(m - n) for m, n in zip(A[:-1], A[1:]))

    print(max_div)

    # 上記の考察より (各要素 + i) // max_div を順番に出力
    for i in range(max_div):
        print(*[(n + i) // max_div for n in A])

main()
